name: Clash é…ç½®ç”Ÿæˆå™¨

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # æ¯6å°æ—¶è¿è¡Œä¸€æ¬¡

jobs:
  build-config:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: æ£€å‡ºä»£ç 
      uses: actions/checkout@v4

    - name: ç”Ÿæˆæ—¶é—´æˆ³
      id: timestamp
      run: |
        current_date=$(date -u +'%Y%m%d-%H%M%S')
        echo "CURRENT_DATE=$current_date" >> $GITHUB_ENV
        echo "TAG_NAME=config-$current_date" >> $GITHUB_ENV

    - name: è®¾ç½®Pythonç¯å¢ƒ
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: å®‰è£…ä¾èµ–
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests

    - name: ç”Ÿæˆé…ç½®æ–‡ä»¶
      run: |
        cat << 'EOF' > generate_config.py
        import base64
        import yaml
        import requests
        import json
        import re
        import logging
        from concurrent.futures import ThreadPoolExecutor

        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )

        class RuleProcessor:
            RULE_PATTERN = re.compile(
                r'^(?P<type>DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD|IP-CIDR|GEOIP|MATCH|PROCESS-NAME),'
                r'(?P<param>[^,]+),'
                r'(?P<group>[^\s,]+)$'
            )

            @classmethod
            def process_rule(cls, line):
                line = line.strip()
                if not line or line.startswith('#'):
                    return None

                # æ ¼å¼è½¬æ¢å¤„ç†
                conversions = {
                    'IP-CIDR': 'GEOIP',
                    'FINAL': 'MATCH'
                }
                for old, new in conversions.items():
                    if line.startswith(old):
                        line = line.replace(old, new, 1)

                # æ ‡å‡†åŒ–è§„åˆ™æ ¼å¼
                match = cls.RULE_PATTERN.match(line)
                if not match:
                    logging.warning(f"è¿‡æ»¤æ— æ•ˆè§„åˆ™: {line}")
                    return None
                
                return f"{match.group('type')},{match.group('param')},{match.group('group')}"

            @classmethod
            def fetch_rules(cls, url):
                try:
                    resp = requests.get(url, timeout=10)
                    return [cls.process_rule(line) for line in resp.text.splitlines()]
                except Exception as e:
                    logging.error(f"è§„åˆ™æºåŠ è½½å¤±è´¥: {url} - {str(e)}")
                    return []

        class ClashGenerator:
            RULE_SOURCES = [
                "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/China/China.list",
                "https://raw.githubusercontent.com/blackmatrix7/ios_rule_script/master/rule/Clash/Global/Global.list",
                "https://raw.githubusercontent.com/DivineEngine/Profiles/master/Clash/RuleSet/Unbreak.list"
            ]

            def __init__(self):
                self.config = {
                    "port": 7890,
                    "socks-port": 7891,
                    "mode": "Rule",
                    "log-level": "info",
                    "proxies": [],
                    "proxy-groups": [
                        {
                            "name": "ğŸš€ èŠ‚ç‚¹é€‰æ‹©",
                            "type": "select",
                            "proxies": []
                        },
                        {
                            "name": "ğŸ¯ å…¨çƒç›´è¿",
                            "type": "select",
                            "proxies": ["DIRECT"]
                        }
                    ],
                    "rules": []
                }

            def load_subscription(self):
                sub_url = "https://raw.githubusercontent.com/Pawdroid/Free-servers/main/sub"
                try:
                    response = requests.get(sub_url, timeout=15)
                    response.raise_for_status()
                    decoded = base64.b64decode(response.text).decode('utf-8')
                    return [line for line in decoded.splitlines() if line.startswith('vmess://')]
                except Exception as e:
                    logging.error(f"è®¢é˜…åŠ è½½å¤±è´¥: {str(e)}")
                    return []

            def parse_vmess(self, link):
                try:
                    config_str = base64.b64decode(link[8:]).decode('utf-8')
                    config = json.loads(config_str)
                    return {
                        "name": config["ps"].strip(),
                        "type": "vmess",
                        "server": config["add"],
                        "port": config["port"],
                        "uuid": config["id"],
                        "alterId": config["aid"],
                        "cipher": "auto",
                        "tls": config.get("tls") == "tls",
                        "network": config.get("net", "tcp")
                    }
                except Exception as e:
                    logging.warning(f"è§£æèŠ‚ç‚¹å¤±è´¥: {link[:50]}... - {str(e)}")
                    return None

            def generate_rules(self):
                with ThreadPoolExecutor(max_workers=5) as executor:
                    results = executor.map(RuleProcessor.fetch_rules, self.RULE_SOURCES)
                
                rules = []
                valid_count = 0
                invalid_count = 0
                
                for result in results:
                    for r in result:
                        if r is not None:
                            rules.append(r)
                            valid_count += 1
                        else:
                            invalid_count += 1
                
                # æ·»åŠ æ ¸å¿ƒè§„åˆ™
                core_rules = [
                    "GEOIP,CN,ğŸ¯ å…¨çƒç›´è¿",
                    "MATCH,ğŸš€ èŠ‚ç‚¹é€‰æ‹©"
                ]
                
                # æœ€ç»ˆè¿‡æ»¤ï¼ˆäºŒæ¬¡éªŒè¯ï¼‰
                final_rules = []
                for rule in core_rules + rules:
                    if RuleProcessor.RULE_PATTERN.match(rule):
                        final_rules.append(rule)
                    else:
                        logging.warning(f"æœ€ç»ˆè¿‡æ»¤æ— æ•ˆè§„åˆ™: {rule}")
                        invalid_count += 1
                
                logging.info(f"è§„åˆ™å¤„ç†å®Œæˆ: æœ‰æ•ˆè§„åˆ™ {len(final_rules)} æ¡, è¿‡æ»¤ {invalid_count} æ¡æ— æ•ˆè§„åˆ™")
                return list(dict.fromkeys(final_rules))

            def generate(self):
                # å¤„ç†èŠ‚ç‚¹
                vmess_links = self.load_subscription()
                valid_nodes = [node for node in (self.parse_vmess(link) for link in vmess_links) if node]
                self.config["proxies"] = valid_nodes
                self.config["proxy-groups"][0]["proxies"] = [p["name"] for p in valid_nodes]
                
                # å¤„ç†è§„åˆ™
                self.config["rules"] = self.generate_rules()
                
                # å†™å…¥æ–‡ä»¶
                with open("sub/config.yaml", "w") as f:
                    yaml.dump(self.config, f, allow_unicode=True, width=2147483647)
                logging.info(f"é…ç½®æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼ŒåŒ…å« {len(valid_nodes)} ä¸ªèŠ‚ç‚¹å’Œ {len(self.config['rules'])} æ¡è§„åˆ™")

        if __name__ == "__main__":
            generator = ClashGenerator()
            generator.generate()
        EOF

        python generate_config.py

    - name: è‡ªåŠ¨ä¿®å¤é…ç½®æ–‡ä»¶
      run: |
        # è¿‡æ»¤æ— æ•ˆè§„åˆ™
        echo "è‡ªåŠ¨ä¿®å¤è§„åˆ™æ ¼å¼..."
        grep -E '^(DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD|IP-CIDR|GEOIP|MATCH|PROCESS-NAME),[^,]+,[^,]+$' sub/config.yaml > temp_config.yaml
        mv temp_config.yaml sub/config.yaml

        # ç¡®ä¿å¿…è¦è§„åˆ™å­˜åœ¨
        required_rules=(
            "GEOIP,CN,ğŸ¯ å…¨çƒç›´è¿"
            "MATCH,ğŸš€ èŠ‚ç‚¹é€‰æ‹©"
        )
        for rule in "${required_rules[@]}"; do
            if ! grep -q "$rule" sub/config.yaml; then
                echo "  - $rule" >> sub/config.yaml
                echo "::notice::å·²æ·»åŠ ç¼ºå¤±è§„åˆ™: $rule"
            fi
        done

        # æ ¼å¼åŒ–YAMLæ–‡ä»¶
        echo "æ ¼å¼åŒ–é…ç½®æ–‡ä»¶..."
        python -c "import yaml; data = yaml.safe_load(open('sub/config.yaml')); open('sub/config.yaml', 'w').write(yaml.dump(data, allow_unicode=True, width=2147483647))"

    - name: æœ€ç»ˆéªŒè¯
      run: |
        # æ£€æŸ¥åŸºæœ¬ç»“æ„
        if ! grep -q 'proxies:' sub/config.yaml || ! grep -q 'proxy-groups:' sub/config.yaml; then
          echo "::error::é…ç½®æ–‡ä»¶ç»“æ„ä¸å®Œæ•´"
          exit 1
        fi

        # æ£€æŸ¥èŠ‚ç‚¹æ•°é‡
        node_count=$(grep -c 'name:' sub/config.yaml)
        if [ "$node_count" -lt 3 ]; then
          echo "::error::æœ‰æ•ˆèŠ‚ç‚¹ä¸è¶³: $node_count"
          exit 1
        fi

        echo "âœ… é…ç½®æ–‡ä»¶éªŒè¯é€šè¿‡"

    - name: åˆ›å»ºç‰ˆæœ¬å‘å¸ƒ
      uses: softprops/action-gh-release@v1
      with:
        files: sub/config.yaml
        tag_name: ${{ env.TAG_NAME }}
        name: "Clash Config ${{ env.CURRENT_DATE }}"
        generate_release_notes: true
        draft: false
        body: |
          è‡ªåŠ¨ç”Ÿæˆçš„ Clash é…ç½®æ–‡ä»¶
          - èŠ‚ç‚¹æ•°é‡: $(grep -c 'name:' sub/config.yaml)
          - è§„åˆ™æ•°é‡: $(grep -c 'rules:' sub/config.yaml)
          - ç”Ÿæˆæ—¶é—´: ${{ env.CURRENT_DATE }}
          - åŒ…å«ä»¥ä¸‹æ ¸å¿ƒè§„åˆ™:
            - GEOIP,CN ç›´è¿
            - è‡ªåŠ¨èŠ‚ç‚¹é€‰æ‹©
            - å¹¿å‘Šæ‹¦æˆªè§„åˆ™
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: ä¸Šä¼ æ—¥å¿—
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: generation-logs
        path: |
          generate_config.py
        retention-days: 1
